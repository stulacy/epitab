---
title: "User Guide"
author: "Stuart Lacy"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, message=F, warning=F}
library(epitab)
library(dplyr)
```

`epitab` is a package that provides functionality for building contingency tables for use in interactive sessions, as well as for publication. The package is designed to be flexible enough to cater to a large number of possible table combinations, allowing for use outside of epidemiology, which it was initially designed for. It was initially designed as an extension to the `Epi::stat.table` function, but being able to handle multiple independent variables with multiple outcomes. Having additional summary measures was useful, although there is little flexibility in how to display them. `epitab` provides by default contingency tables of an unlimited number of variables, in addition to supporting summary measures across both rows and columns. This vignette provides an overview of the types of tables that can be built using `epitab`.

## Data

To demonstrate the package, a dummy data set representing an observational study of a disease will be used. The disease mostly affects elderly people, and not everyone is provided treatment. The disease itself comes in two variants *A* and *B*.

```{r}
set.seed(17)
treat <- data.frame(age=abs(rnorm(100, 60, 20)),
                    sex=factor(sample(c("M", "F"), 100, replace=T)),
                    variant=factor(sample(c("A", "B"), 100, replace=T)),
                    treated=factor(sample(c("Yes", "No"), 100, replace=T)))
treat$agebin <- cut(treat$age, breaks=c(0, 40, 60, 80, 9999),labels=c("0-40", "41-60", "61-80", "80+")) 
```

```{r}
treat %>%
    head() %>%
    knitr::kable()
```

## Simple contingency tables

Simple contingency tables are useful when running an initial exploratory analysis of a data set. The code example below shows an example where we're interested in seeing how treatment varies by standard demographic factors. Both the independent and outcome variables are passed in as named lists, with the name providing the column or row label as it will appear in the table. The variable name **must** be the column name as a quoted string. This allows for these tables to be used in automated scripts. The `crosstab_funcs` argument specifies what summary measures should be calculated for each independent variable / outcome combination. The `freq` function calculates the frequency of each of these cells, and (optionally) provides the proportion in parantheses.

```{r}
contingency_table(independents=list("Age"="agebin",
                                    "Sex"="sex"),
                  outcomes=list("Treated"="treated"),
                  crosstab_funcs=list(freq()),
                  data=treat)
```

Note that the presence of the overall frequency column is controlled by the `marginal` argument. There are also options to `freq` that specify the formatting of the cross-tabulated frequencies. See `?freq` for more details.

```{r}
contingency_table(independents=list("Age"="agebin",
                                    "Sex"="sex"),
                  outcomes=list("Treated"="treated"),
                  crosstab_funcs=list(freq(proportion = "none")),
                  marginal=FALSE,
                  data=treat)
```

Note that multiple outputs can be included, although the maximum dimensionality of any cross-tabulations is 2 dimensions.

```{r}
contingency_table(independents=list("Age"="agebin",
                                    "Sex"="sex"),
                  outcomes=list("Treated"="treated", "Variant"="variant"),
                  crosstab_funcs=list(freq()),
                  data=treat)
```

## Adding additional information

The contingency tables above provide simple short summaries of categorical variables in the data. However, it is frequently desired to add supplementary information, either from continuous variables in the data, or outcomes of regression modelling. `epitab` allows for additional data to be provided alongside the contingency-table, specified as either *row-wise measures* (those that act on every row of the table), or *column-wise measures* (those that act on every column).


### Row-wise measures

A common addition to a contingency table is displaying the output of a regression model that relates the independent variables with the outcome, where a separate coefficient is provided for each level of every independent variable. For example, we may be interested to see how the treatment varies by age in a more involved manner than simply listing the proportions. An appropriate course of action would be to fit a univariate logistic regression with `treated` as the response and look at the odds ratios of each factor level. 

The `row_funcs` argument to `contingency_table` allows for the specification of this behaviour. It accepts a named list of functions that meet the correct requirements, with the two being provided with this package `odds_ratio` and `hazard_ratio` used to display coefficients resulting from logistic regression and Cox regression respectively, see their help pages for further support. The example below shows how to specify that the odds ratios should be calculated in addition to the cross-tabulated frequencies. These functions also display confidence intervals alongside the point estimate. The only required argument to `odds_ratio` is the name of the outcome variable. 

```{r}
contingency_table(list("Age"="agebin",
                       "Sex"="sex"),
                  outcomes=list("Treated"='treated'),
                  data=treat, 
                  crosstab_funcs=list(freq()),
                  row_funcs=list("OR"=odds_ratio('treated')),
                 )
```

Arguments to `odds_ratio` allow the logistic regression model to adjust for every other variable included in `independents` and also to use the largest group as the baseline. Note that multiple functions can be provided to `row_funcs`. While the table below may not fit on the page of this document, it fits neatly within the standard R terminal output.

```{r}
contingency_table(list("Age"="agebin",
                       "Sex"="sex"),
                  outcomes=list("Treated"='treated'),
                  data=treat, 
                  crosstab_funcs=list(freq()),
                  row_funcs=list("OR"=odds_ratio('treated', relevel_baseline=TRUE),
                                 "Adj OR"=odds_ratio('treated', adjusted=TRUE, relevel_baseline=TRUE))
                 )
```

Another use case in epidemiology is where survival is the outcome of interest. For this example we'll use the `prevsim` data set from the `rprev` package that has been designed to simulate a real world cancer registry.

```{r, message=F}
library(rprev)
data(prevsim)
head(prevsim)
```

For this example, the contingency table will display five year survival. Also, age is continuous in the original data set so it will be discretised into intervals.

```{r}
prevsim$fiveyrsurv <- as.factor(as.numeric(prevsim$time > 365.25*5))
prevsim$agegrp <- cut(prevsim$age, breaks=c(0, 60, 80, 150), 
                      labels=c('0-60', '60-80', '>80'))
```

As with `odds_ratio`, `hazard_ratio` accepts the outcome as an argument. This is now a string specifying the nature of the survival object, as is commonly used in the `survival` package.

```{r}
contingency_table(independents=list("Age"="agegrp",
                                    "Sex"="sex"),
                  outcomes=list("5-year"="fiveyrsurv"),
                  data=prevsim,
                  crosstab_funcs=list(freq()),
                  row_funcs=list("HR"=hazard_ratio("Surv(time, status)"),
                                 "Adj HR"=hazard_ratio("Surv(time, status)", adjusted=TRUE))
                  )
```

### Column-wise measures

It is often the case that there are continuous variables in the data set that we'd like the see the relationship with the outcome without being discretised. *col_funcs* calculates summary measures for each level of the outcome outside of the main contingency table and can be used for this purpose. Default functions that are included with `epitab` include `summary_mean` and `summary_median`, which calculate a summary value of a given continuous variable for each level of the outcomes. The example below shows calculating the mean age across treatment types, providing an additional insight into the relationship between these two variables beyond that given in the contingency tables by the age groups.

```{r}
contingency_table(independents=list("Age"="agebin",
                                    "Sex"="sex"),
                  outcomes=list("Treated"="treated"),
                  crosstab_funcs=list(freq()),
                  col_funcs=list("Mean age"=summary_mean("age")),
                  data=treat)
```

As with `crosstab_funcs` and `row_funcs`, multiple summary values can be calculated.

```{r}
contingency_table(independents=list("Age"="agebin",
                                    "Sex"="sex"),
                  outcomes=list("Treated"="treated"),
                  crosstab_funcs=list(freq()),
                  col_funcs=list("Mean age"=summary_mean("age"),
                                 "Median age"=summary_median("age")),
                  data=treat)
```

### Tips

There is no limit to the number of column-wise and row-wise functions that can be supplied.

```{r}
contingency_table(independents=list("Age"="agebin",
                                    "Sex"="sex"),
                  outcomes=list("Treated"="treated"),
                  crosstab_funcs=list(freq()),
                  col_funcs=list("Mean age"=summary_mean("age"),
                                 "Median age"=summary_median("age")),
                  row_funcs=list("OR"=odds_ratio('treated', relevel_baseline=TRUE),
                                 "Adj OR"=odds_ratio('treated', adjusted=TRUE, relevel_baseline=TRUE)),
                  data=treat)
```

Likewise with outcome variables, allowing for a large amount of information to be contained in a single table. This flexibility of `epitab` allows for either simple summary tables that are used to highlight a trend within the data, or more complex reference tables that hold a large amount of summary statistics.

```{r}
contingency_table(independents=list("Age"="agebin",
                                    "Sex"="sex"),
                  outcomes=list("Treated"="treated", "Disease variant"="variant"),
                  crosstab_funcs=list(freq()),
                  col_funcs=list("Mean age"=summary_mean("age"),
                                 "Median age"=summary_median("age")),
                  row_funcs=list("Treatment OR"=odds_ratio('treated', relevel_baseline=TRUE),
                                 "Disease variant OR"=odds_ratio('variant', relevel_baseline=TRUE)),
                  data=treat)
```

Tables can even be provided when there are no contingency tables. Useful for providing a neat way of displaying regression coefficients.

```{r}
contingency_table(independents=list("Age"="agebin",
                                    "Sex"="sex"),
                  row_funcs=list("OR"=odds_ratio('treated', relevel_baseline=TRUE),
                                 "Adj OR"=odds_ratio('treated', adjusted=TRUE, relevel_baseline=TRUE)),
                  data=treat)
```

## Publication ready tables

The default `print` method of these contingency tables is designed for a standard wide R console where the entire table fits into view. All of the above tables have no problem correctly displaying when run in a R console, as is the case for the vast majority of day-to-day data analysis. However, for situations where a table is being produced for publication of any type, greater attention to detail and appearance is required. `epitab` provides several options for producing tables to distribute.

### `neat_table`

The `neat_table` function provided in `epitab` builds a neatly formatted table for output to HMTL or LaTeX, using `knitr::kable` and the `kableExtra` package. The output of `neat_table` is still a `kable` object and so can be passed to `kableExtra::kable_styling()`, allowing for the specification of various cosmetic options, such as striped rows and highlighting on mouse hover. See the help files for both `neat_table` and `kableExtra::kable_styling` for further details.

```{r}
contingency_table(independents=list("Age"="agebin",
                                    "Sex"="sex"),
                  outcomes=list("Treated"='treated'),
                  crosstab_funcs=list(freq()),
                  row_funcs=list("OR"=odds_ratio('treated'),
                                 "Adj OR"=odds_ratio('treated', adjusted=TRUE)),
                  col_funcs=list("Mean age"=summary_mean("age")),
                  data=treat) %>%
              neat_table() %>%
              kableExtra::kable_styling(bootstrap_options=c("striped", "hover"), full_width=FALSE)
```

Due to the vignette markdown theme, these styling changes won't appear in this vignette HTML, but they will appear in your own markdown documents. The image below shows how the table is displayed in the default Rmarkdown template using the same code as above.

![`neat_table()` HTML example](neat_html.png)

### `kable`

If full control of the table appearence is required, then the raw character matrix is provided in the output of `contingency_table`, and it can be used with the fantastic `knitr::kable`. The `kableExtra` package also provides excellent functionality for neat tables, **although again note that these changes will not display in the output vignette, but they will in your markdowns**.

NB: The default value for `option` in `kable` is *pandoc* which doesn't work well with these contingency tables so specify either *html* or *markdown* instead.

```{r}
knitr::kable(contingency_table(list("Age"="agebin",
                                    "Sex"="sex"),
                               outcomes=list("Treated"='treated'),
                               crosstab_funcs=list(freq()),
                               row_funcs=list("OR"=odds_ratio('treated'),
                                              "Adj OR"=odds_ratio('treated', adjusted=TRUE)),
                               data=treat)$mat,
             "html") %>%
        kableExtra::kable_styling(bootstrap_options="striped")
```

### PDF

For outputting to PDF documents using LaTeX, the same `neat_table` function can be used, but now it must be specified to use the `latex` output format. Also it is **highly** recommended to use the `booktabs` argument to produce far cleaner tables.

```{r, eval=F}
contingency_table(independents=list("Age"="agebin",
                                    "Sex"="sex"),
                  outcomes=list("Treated"='treated'),
                  crosstab_funcs=list(freq()),
                  row_funcs=list("OR"=odds_ratio('treated'),
                                 "Adj OR"=odds_ratio('treated', adjusted=TRUE)),
                  col_funcs=list("Mean age"=summary_mean("age")),
                  data=treat) %>%
              neat_table('latex', booktabs=TRUE) %>%
```

The above call will display the table below using the default Rmarkdown template.

![`neat_table()` LaTeX example](neat_latex.png)

### Word / Excel

TODO Test this

## Custom functions

In the above examples, the summary functions used to build up the table in `crosstab_funcs`, `row_funcs`, and `col_funcs` have been specified as functions provided by `epitab`. However, for greater flexibility, any correctly-specified function can be passed to provide statistics of interest. This section details the appropriate form for each of these 3 types..

### Cross-tabulated

The functions passed in to `crosstab_functions` are run for each combination of outcome and independent variable level.

Arguments:

  - `outcome_level`: A string providing the current outcome level.
  - `outcome_name`: A string providing the current outcome variable.
  - `data`: A subset of the full data, to comprise individuals with the current independent variable level
  
The function must return a vector of length one, and that can be coerced to a character.

The example function below calculates the proportion of each outcome per independent variable level, rather than also displaying the frequency as `freq` does.

```{r}
proportion <- function(outcome_level, outcome_name, data) {
    outcome_count <- sum(data[[outcome_name]] == outcome_level)
    proportion <- outcome_count / nrow(data)
    round(proportion, 2)
}
```

```{r}
contingency_table(independents=list("Age"="agebin",
                                    "Sex"="sex"),
                  outcomes=list("Treated"="treated"),
                  crosstab_funcs=list(proportion),
                  data=treat)
```

### Row-wise

The row-wise functions that are supplied with `epitab` are `odds_ratio` and `hazard_ratio`, and are used to estimate summary measures for the independent variables outside of the contingency table. This can be useful for providing a summary statistic that is not necessarily related to the outcome variables. This example will describe the case where there is a continuous outcome and we wish to run a linear regression on it with the independent variables. For this demonstration, the continuous outcome is age - which is not a particularly useful thing to do, especially when one of the independent variables is age group, but it will serve as an example. These functions must be parameterised as follows:

Args:

  - `var`: The current independent variable, as string.
  - `all_vars`: All independent variables as passed into `independents`. Character vector.
  - `data`: The data set passed into `data`.

The function must return a character vector (or at least something that can be coerced to character) with the length of the number of levels of `cat_var`.

```{r}
lr <- function(var, all_vars, data) {
    levs <- levels(data[[var]])
    form <- as.formula(paste('age ~', var))
    mod <- lm(form, data)
    coefs <- c(coef(mod), 1)  # Add baseline as 1
    # coefficients are named with <variable><level>
    labels <- paste0(var, levs)
    # set baseline name in coefficients vector
    names(coefs)[length(coefs)] <- labels[1]
    coefs[labels]
}
```

```{r}
contingency_table(list("Age"="agebin",
                       "Sex"="sex"),
                  outcomes=list("Treated"='treated'),
                  data=treat, 
                  crosstab_funcs=list(freq()),
                  row_funcs=list("Regression on age"=lr),
                 )
```

### Column-wise

Column-wise functions are used to investigate relationships between the outcome variables that aren't necessarily associated with the categorical independent variables. The functions provided with `epitab` are `summary_mean` and `summary_median`, and provide a typical use-case of summarising a continuous variable for each level of the outcome.

Args:

  - `outlevel`: The current level of the outcome, as a character vector.
  - `outcome`: The current outcome, as a character vector.
  - `data`: The full data set that was passed to `contingency_table`

Returns:

The function must return a single value that can be coerced to a string.

The example function below extends `summary_mean` by adding the standard deviation in parantheses. It is hardcoded to work for a single continuous variable, age.

```{r}
meanage_sd <- function(outlevel, outcome, data) {
    sub_data <- data[data[[outcome]] == outlevel, ]
    mean <- round(mean(sub_data[['age']]), 2)
    sd <- round(sd(sub_data[['age']]), 2)
    paste0(mean, " (", sd, ")")
}
```

```{r}
contingency_table(independents=list("Age"="agebin",
                                    "Sex"="sex"),
                  outcomes=list("Treated"="treated"),
                  crosstab_funcs=list(freq()),
                  col_funcs=list("Mean age"=summary_mean("age"),
                                 "Mean age (sd)"=meanage_sd),
                  data=treat)
```